# Networking Advanced Topic Presentations

Before your presentation, use this file to get your talk outline approved. Be
sure to provide an estimated time to spend on teach topic (totalling 45 minutes)
and be sure not to repeat any topics covered in previous presentations.

## Presentation I

Alexander Haurin,
Liying Qin
& Griffin Jordan

- Intro (10 minutes)
  
  - Explanation of goals we are aiming to achieve for our networking team:
    - Flawless multiplayer over a flawed system (expanding on what we mean by flawless e.g., synchronicity and scale)
    - how our approach will differ from other types of games (real-time FPS vs. a turn based card game)
  - Networked multiplayer in older games (90s to early 2000s)
    - Explain differnces of Peer-to-peer (P2P) vs Client-Server model
        - bandwidth limitations
        - why one is better than the other
    - LAN reducing latency, but comes with tradeoffs like connectivity over distance
    - Latency problems on networked connection: i.e handling of dropped connections and reconnecting
    - Explain how detecting and preventing cheating was much harder back then
    - Shining examples: DOOM, Unreal Tournament, Goldeneye and Mario Kart 64 (true pioneers)
  - Networked multiplayer in modern games (2010s to present)
    - Show how server architecture has greatly improved with things like dedicated servers and cloud-based solutions and saving
    - Real-time game data streaming (this will be important for our stretch goal of a stats & leaderboard system)
    - Show how scale and synchronicity has improved with time. Even complex ideas like cross-platform multiplayer that games can still struggle with today
    - Majority of games today come with the assumption of some level of multiplayer functionality
    - Shining examples: minecraft, GTA, Halo and of course **Counter-Strike**
  - Our approach to networking and how it differs/is similar to older and modern multiplayer networking solutions
  - Player host approach
  
- Server Implementation (15 minutes)
  - rust std::net
  - State Management
    - will be representing players cards, chips/$ amount, actual players and more
    - synchronization of these components across all clients is neccessary for proper game flow
    - things like the river cards should be represented on each players game. Can't have different river cards for different players
    - state management is incredibly important to keep the competitive integrity of poker alive
  - Lobby & Matchmaking system
    - Explaination of lobbys in poker game
    - player host creates a lobby or room which has a unique code
    - other players who wish to join can do so by entering a code generated by the host
    - Once everyone is in, game may begin
    - termination of game occurs when host chooses so. Specific triggers to allow for the start and stop of a game or lobby
    
- Client-Server Communication (10 minutes)
  - Player as host implementation
  - describe the cost and benefits of this approach
  - desirable experience for the host, other players may not have the same.
  - expand on this by showing the path data must go to be reached by players ... peer --> host --> peer
  - Serde
  - Protocol design
  - even though poker is turn based, we still must ensure each turn is the same for everyone
  - ex: game events such as the dealing of cards need to be represented on everyones screen
      - though some data needs to be hidden from users, most notably other players hands
  - player actions like betting, folding, checking, etc. and how we communicate that with other players
    - sure, its okay for other players to know something like a bet amount
  - game state updates
    - do we really need to transmit certain data to all players the time? No, some things are just not that important or act as unneccessary overhead and can stay localized 
      until needed. 
  - How we plan to handle latency, even though poker is not real-time

- Connection Management (10 minutes)
  - Accidental disconneciton is a very real problem
  - how we plan to handle such a case
  - reconnection and a saved game state
  - ambitious, but replacing disconnected player with bot
  - we don't just want the game to end and drop connection if one player in game gets disconnected
  - no one likes getting the "failure to connect to server" error, this can be better managed with our approach to implementing multiplayer
  - showcase how by having a player host and peer to peer type of networked multiplayer, we dont need to rely on outside servers to be running


## Presentation II

- UDP Connections and Reliability (15 minutes)
  - What does TCP offer that UDP doesn't have
  - Why we can't use TCP for an action game
  - How to replicate connections in UDP
  - How to replicate packet ordering in UDP
  - How to replicate packet resending in UDP
  - How to handle congestion
  - Case study by explaining host.rs
- Game synchronization and agreement (15 minutes)
  - Everyone is simulating the game locally
  - The host is the source of truth for what really happened
  - Describe the flow of information
  - Describe sources of latency
  - Describe clientside prediction
  - Describe prediction correction
  - Case study in collisions with the local player
- Lag compensation (15 minutes)
  - Because of latency, actions made by the player arrive at the server when state has changed
  - For fairness, a player should have their inputs evaluated against the state in which they were created
  - solutions: delay, lag comp, rollback
  - delay means that you see your own inputs late, rather than predicting them you wait for the server to respond
  - lag comp means you predict, and when the server gets your inputs it checks how the world looked at the time of input and applies the effect that would occur. meaning you can get shot through walls.
  - rollback is like lag comp, but instead of just applying the effect at that point in time it is received, it resimulates the world from the input onward as if the input had come in earlier.
  - why we aren't doing true rollback and instead doing lag comp
  - credit to source developer wiki


## Presentation III

- Latency (30 minutes)
  - Deterministic Replication (DR)
      - What is determinism?
          - IEEE 754 and float point
      - No physics in Far From Fatality
      - Feasible? 
  - Authoritative Replication (AR)
    - Overwatch Implementation and examples
      - Receive inputs
          - Keypresses
      - Send game state
          - Bevy's gamestate is not typical gamestate
      - Why this is the one used in Far From Fatality
          - Fallback plan
          - Segway into hybrid design because AR may potentially solve problems.
  - Delayed Input on the Client
      - Why delayed inputs?
          - Demonstration of delayed input, frame-by-frame
      - Why client specifically?
          - To hopefully solve rollback issues
  - Rollback on the Server
      - Why rollback?
          - Demonstration of simple prediction and rollback, frame-by-frame
      - Why server specifically?
          - Rollback and prediction is replicated
  - Hybrid Delayed and Rollback
      - Why we think the hybrid model works
  - Questions?
- Bandwidth Optimization (15 minutes)
  - Network Topology
      - Network Classifications
          - Point to Point
          - Bus
          - Mesh
          - Star
      - Why we went with star?
      - Server Hosting in our game
      - Client Connection in our game
  - Bandwidth 
      - Network Speed
      - Throughput
      - Bandwith and UDP/TCP
      - How does this affect our game?
  - Packets
      - Basic packet sending
      - Packet sending in our game
          - What are we sending?
          - How is it stored?
          - How is it sent?
      - Using the packets in our game
          - How are we collecting the packets?
          - How are we implementing the information that it gives?
              - How it affects players
              - How it affects enemies
              - How it affects environment
      - How does our delayed model affect Packet sending?
...


## Presentation IV
- Networking Framework and Custom Protocol Analysis (15 minutes)
    - Game Architecture Overview for Multiplayer in our game
        - Explanation of the High-level architecture of our game, focusing on the networking components and code
        - Client-server model and how it suits our game's requirements/needs
        - Challenges faced during the implementation of our specific game architecture regarding multiplayer
        - How certain decisions in networking architecture influenced gameplay
    - Implementation of Networking Protocols in our game
        - Details on the protocols used for communication
        - Explanation of how our data is structured and transmitted over the network
    - Other considerations for Networking Frameworks and Custom Protocols
        - Explanation of routes we explored/could've taken
        - Explanation of other ways games can handle their architecture
- Game State Management and Latency Handling (15 minutes)
    -Project management to integrate network directly into game state
        -GameState
        -MultiplayerState
    -Discuss using Bevy states and events to trigger client-server communication
        -NetworkingState
        -Updating on events
        -Struggles with incorporating networking into our game
    -Problems with our architecture we had to address
        -Blocking
        -Switching from TCP to UDP
- Networking Security Protocols (15 minutes)
    - Background of why we chose to implement a preliminary security system following the flow of Threat Analysis -> Design -> Mechanism -> Implementation
    - Importance of security in networking communications: 
        - Data confidentiality to prevent unauthorized access to sensitive information
        - Data integrity  + Availability and Threats vs exploits
        - Man in the Middle Attacks example
        - SLL vs SSH
    - Foundations of Public key cryptography
        - Trade-offs between public key cryptography and symmetric key cryptography. 
        - Diffie-Hillman secure key exchange and RSA overview
        - Digital signatures overview.
    - Our networking security design and implementation:
        - What threats are we protecting against and why we chose to make our server fully trusted
        - Out-of-band key generation and distribution 
        - Client-Server mutual authentication steps along with what a challenge is.
        - How our implementation prevents replay attacks  
        - Shared private session secret development utilizing AES between each client and server.
        - Informal proof justifying security and correctness. 
    - Rust implementation challenges: 
        - Packages we chose to utilize 
        - Choices we made in terms of key size, block modes, and padding modes and what went into making these decisions. 
    - Final thoughts on security in networking and assurances. 
        - Leverage real-world examples to explain the concept of assurance and how most security mechanisms are built upon it + formal mathematics.  
...
